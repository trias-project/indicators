---
title: "Preparing meeting about occurrence indicators: how detect emerging species"
author:
- Damiano Oldoni
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Load libraries

Install `trias` package:

```{r install_packages}
devtools::install_github("trias-project/trias")
```

Load libraries:

```{r load_libraries}
# Graphic packages
library(ggplot2)
library(sf)
library(sp)
library(rgdal)
library(raster)
library(rgeos)
# Tidyverse packages
library(tidyr)
library(dplyr)
library(purrr)
library(readr)
library(stringr)
# examine and clean dirty data
library(janitor)
# handle large files
library(inborutils)
# manage databases
library(DBI)
library(RSQLite)
# time series package
library(zoo)
# Downscale package
library(downscale)
# GBIF related packages
library(rgbif)
# Project package
library(trias)
```

## Set coordinate reference systems

GBIF occurrence data use WGS84 projection:
```{r set_crs}
# CRS used by GBIF
wgs_84 <- st_crs("+init=epsg:4326") 
```

# Get data

## Import UTM grids

First, we import UTM grids of Belgium at 5 by 5 km with CRS (Coordinate Reference System) Belge Lambert 1972:

```{r import_grids_5km}
belgium_5grid <- st_read("../data/external/utm5_bel", "utm5_bel")
crs_data <- st_crs(belgium_5grid)
``` 

## Import occurrence data

We can import test data based on a previous download related to all birds, ladybirds and plants in Belgium with geographic coordinates. Taxa details can be found in `../data/input/occ_indicator_emerging_species_part1.tsv`, `*part2.tsv` and `*part3.tsv`. First we define the GBIF download keys we refer to:

```{r gbif_download_key}
gbif_download_keys <- c("0003457-181003121212138", # Plantae
                        "0003482-181003121212138", # Coccinellidae
                        "0003489-181003121212138"  # Aves
)
```

We download the large zip files if not done already:

```{r load_occ_data}
map(gbif_download_keys, function(x) {
  if (!file.exists(paste0("../data/interim/", x, "_occurrence.txt"))) {
    occ <- occ_download_get(key = x, overwrite = T, path = "../data/interim/")
    fn <- "occurrence.txt"
    unzip(zipfile = occ, files = fn, exdir = "../data/interim")
    file.rename(from = "../data/interim/occurrence.txt", 
                to = paste0("../data/interim/", x, "_occurrence.txt"))
  } else {
    paste0("File ", paste0("../data/interim/", x, "_occurrence.txt"),
           " already exists.")
  }
})
```

The files are very large. We copy them to `SQLite` files (extension `.db`) via INBO utility function `csv_to_sqlite()`. If the databases already exist then a message is returned:

```{r convert_to_sqlite}
csv_files <- map_chr(gbif_download_keys, function(x) {
  paste0("../data/interim/", x, "_occurrence.txt")
})
sqlite_files <- map_chr(gbif_download_keys, function(x) {
  paste0("../data/interim/", x, "_occurrence.db")
})

table_names <- gbif_download_keys

pmap(list(csv_files, sqlite_files, table_names), function(x, y, z) {
  if (file.info(y)$size > 0) {
    paste0("Text file ",x," already copied to SQLite database ", y, ".")
  } else {
    csv_to_sqlite(x, y, z, delim = "\t", 
              trim_ws = TRUE, escape_double = FALSE,
              show_progress_bar = TRUE)
  }
})
```

### Define species under study

We are interested in the following alien species:

species | kingdom | GBIF backbone key
--- | --- | ---
Baccharis halimifolia | Plantae | 3129663
Impatiens glandulifera | Plantae | 2891770
Impatiens capensis | Plantae | 2891774
Hydrocotyle ranunculoides | Plantae | 7978544
Branta canadensis | Animalia | 5232437
Harmonia axyridis | Animalia | 4989904

```{r set_alien_species}
alien_species <- data.frame(
  species = c("Baccharis halimifolia",
              "Impatiens glandulifera",
              "Impatiens capensis",
              "Hydrocotyle ranunculoides",
              # "Branta canadensis", uncomment if problem with db "0003489-181003121212138" is solved
              "Harmonia axyridis"),
  taxonKey = c(3129663, 
               2891770, 
               2891774, 
               7978544, 
               # 5232437, uncomment if problem with db "0003489-181003121212138" is solved
               4989904),
  gbif_download_key = c(gbif_download_keys[1],
                        gbif_download_keys[1],
                        gbif_download_keys[1],
                        gbif_download_keys[1],
                        # gbif_download_keys[3], uncomment if problem with db "0003489-181003121212138" is solved
                        gbif_download_keys[2]),
  dbase = c(sqlite_files[1], 
            sqlite_files[1],
            sqlite_files[1], 
            sqlite_files[1],
            # sqlite_files[3], uncomment if problem with db "0003489-181003121212138" is solved
            sqlite_files[2]),
  stringsAsFactors = FALSE
  ) %>%
  as_tibble()
```

We are interested to the information related to the following fields:

```{r select_cols}
cols_to_select <- c("gbifID", "references", "rightsHolder", 
"datasetName", "datasetKey", "basisOfRecord",
"occurrenceID", "eventDate", "year", "month", "day",
"countryCode", "decimalLatitude", "decimalLongitude",
"coordinateUncertaintyInMeters", "verbatimCoordinateSystem",
"issue", "hasCoordinate",
"hasGeospatialIssues", "taxonKey", "kingdomKey", "phylumKey",
"classKey", "orderKey", "familyKey", "genusKey", 
"subgenusKey", "speciesKey", "species")
```

We define first the function to extract the needed data from databases, called `extract_occ`:

```{r define_function}
extract_occ <- function(db, table, taxa) {
  my_db <- src_sqlite(db, create = FALSE)
  occ_db <- tbl(my_db, table)
  results <- occ_db %>% 
    dplyr::select(one_of(cols_to_select)) %>%
    dplyr::filter(speciesKey == taxa) %>%
    dplyr::as_tibble()
  return(results)
}
```

Extract data as a standard data frame:

```{r extract_occ_alien_as_df}
progress_bar <- progress_estimated(nrow(alien_species))

occ_alien <- pmap_df(
  list(
    alien_species$dbase,
    alien_species$gbif_download_key,
    alien_species$taxonKey),
  function(x, y, z) {
    progress_bar$tick()$print()
    extract_occ(x, y, z)
  }
)
```

# Explore and pre-process data

Data without taxonomic information:

```{r}
occ_alien %>%
  filter(is.na(species), 
         is.na(taxonKey))
```

We remove them:

```{r remove_occ_with_no_taxa_info}
occ_alien <- occ_alien %>%
  filter(!is.na(taxonKey))
```

## Explore temporal information

Number of occurrences without temporal information (`year`):

```{r presence_year}
occ_alien %>%
  filter(is.na(year)) %>% 
  group_by(speciesKey) %>%
  count() %>%
  arrange(desc(n)) %>%
  full_join(alien_species %>% 
              select(taxonKey, species), 
            by = c("speciesKey" = "taxonKey"))
```

We remove them:

```{r remove_occ_without_year}
occ_alien <- occ_alien %>%
  filter(!is.na(year))
```

Overview number of occurrences per species left:

```{r count_occ}
occ_alien %>%
  group_by(speciesKey) %>%
  count() %>%
  arrange(desc(n)) %>%
  left_join(alien_species %>% 
              select(taxonKey, species), 
            by = c("speciesKey" = "taxonKey"))
```

## Explore geographical information

Uncertainty on position is given in `coordinateUncertaintyInMeters` while in `verbatimCoordinateSystem` we can get details about the coordinate system used while collecting data:

```{r}
occ_alien %>% 
  group_by(coordinateUncertaintyInMeters, verbatimCoordinateSystem) %>%
  count() %>%
  arrange(desc(n))
```

There are data without coordinate uncertainty and coordinate system:

```{r}
occ_alien %>% 
  filter(is.na(coordinateUncertaintyInMeters) & is.na(verbatimCoordinateSystem)) %>%
  group_by(datasetKey, datasetName, speciesKey, species) %>%
  count() %>%
  arrange(desc(n))
```

We remove them:

```{r remove_Data_without_coord_uncertainty_and_crs}
occ_alien <- occ_alien %>% 
  filter(!is.na(coordinateUncertaintyInMeters) | !is.na(verbatimCoordinateSystem))
```

## Handle suspicious data

Special attention should be taken to analyze suspicious data, that is data without spatial uncertainty. For example, we can decide to remove all data without spatial coordinates, spatial uncertainty:

```{r show_suspicious_data}
stat_suspect_data <- occ_alien %>%
  group_by(!is.na(coordinateUncertaintyInMeters),
           !is.na(verbatimCoordinateSystem),
           datasetKey, datasetName, species) %>%
  count() %>%
  arrange(desc(n)) %>%
  rename("presence_coord_uncertainty" = "!is.na(coordinateUncertaintyInMeters)",
         "presence_coord_system" = "!is.na(verbatimCoordinateSystem)")
stat_suspect_data
```

Alternatively, different strategies could be taken in order to improve the quality of the data. In some cases, based on the coordinate system information, we can detect an erroneous interpretation of the definition of coordinate uncertainty.

Soft handling: 
- **we assign an uncertainty of 10 meters for data without uncertainty**

```{r assign_default_10m_uncertainty}
occ_alien <- occ_alien %>%
  mutate(coordinateUncertaintyInMeters = ifelse(
    is.na(coordinateUncertaintyInMeters), 10.0, coordinateUncertaintyInMeters)
  )
```

# Build presence-absence atlas data

First, we create points based on latitude and longitude:

```{r create_polygons}
occ_pts <- st_as_sf(occ_alien, coords = c('decimalLongitude', 'decimalLatitude'), 
                    crs = wgs_84)
```

We can then create circles based on `coordinateUncertaintyInMeters` as radius:

```{r create_circles}
# set coordinate system equal to Lamber 1972
occ_pts_lambert <- st_transform(occ_pts, crs_data)
occ_pts_lambert <- st_buffer(occ_pts_lambert, 
                             dist = occ_pts_lambert$coordinateUncertaintyInMeters,
                             nQuadSegs = 6)
```

We intersect occurrence circles with the grid per each species and year:

```{r intersection}
spatial_fit <- st_intersection(belgium_5grid, occ_pts_lambert)

oar <- spatial_fit %>% 
  mutate(n_float =
           as.numeric(st_area(.))/(coordinateUncertaintyInMeters^2*pi)) %>%
  group_by(species, year, TAG) %>%
  summarize(n = round(sum(n_float))) %>% 
  arrange(desc(n))
```

We assign 1 (presence) to the squares with at least one occurrence, 0 otherwise:

```{r assign_to_centroids}
pres_abs_table <- belgium_5grid %>% 
  crossing(data.frame(year = seq(min(oar$year, na.rm = TRUE),
                                 max(oar$year, na.rm = TRUE)))) %>%
  crossing(data.frame(species = alien_species$species, 
                      stringsAsFactors = FALSE)) %>%
  left_join(data.frame(oar, stringsAsFactors = FALSE) %>%
              dplyr::select(species, year, TAG, n),
            by = c("species", "year", "TAG")) %>%
  mutate(presence = ifelse(!is.na(n) & n >= 1, 1, 0))
```

A presence-absence table per species and year is ready.

## Plot area of occupancy (AOC)

For each species, we show the number of occupied squares per year:

```{r plot_per_species_per_year}
map(alien_species$species, function(x) {
  ggplot(pres_abs_table %>%
         filter(species == x & presence == 1) %>%
           group_by(year), 
       aes(year)) + 
geom_bar(stat = "count") +
    ggtitle(x)
})
```

The number of occupied squares is proportional to the area of occupancy. We show the latter one in percentage:

```{r plot_area_of_occupancy}
map(alien_species$species, function(x) {
  ggplot(pres_abs_table %>%
         filter(species == x & presence == 1) %>%
           group_by(year) %>%
           summarize(aoc = n()/nrow(belgium_5grid)*100), 
       aes(year, aoc)) + 
    geom_col() +
    ggtitle(x) +
    labs(x = "year", y = "AOC (%)")
})
```

# Apply search effort correction

It is widely demonstrated that search effort is not constant over time and species. We try to take correct the AOC results by this bias.

```{r general_classes}
general <- c("Plantae", "Coccinellidae")
```

We have to reduce the number of selected columns from database in order to calculate the number of occurrences per year for all plants without getting a _memory out of range_ error:

```{r cols_to_select_total}
cols_to_select_bigdata <- c("decimalLongitude", "decimalLatitude",
                            "year", "taxonKey", "speciesKey", "species")
```


```{r function_calculate_occ_total}
calculate_occ_total <- function(db, table, select_cols) {
  get_db <- src_sqlite(db, create = FALSE)
  occ_db <- tbl(get_db, table)
  occ_per_square_bigdata <- occ_db %>% 
    as.data.frame() %>%
    select(one_of(select_cols)) %>% 
    filter(!is.na(year)) %>%
    st_as_sf(coords = c('decimalLongitude', 'decimalLatitude'), 
             crs = wgs_84) %>%
    st_transform(crs_data) %>%
    st_join(belgium_5grid,
            join = st_intersects) %>%
    group_by(year) %>%
    count() %>% 
    arrange(desc(n)) %>%
    as_tibble()
  return(occ_per_square_bigdata)
}
```

Plants:

```{r plants}
n_occ_plants <- calculate_occ_total(db = sqlite_files[1],
                                    table = gbif_download_keys[1],
                                    cols_to_select_bigdata)
n_occ_plants <- left_join(data.frame(year = c(min(n_occ_plants$year):max(n_occ_plants$year)),
                                        stringsAsFactors = FALSE),
                             n_occ_plants,
                  by = "year") %>%
  mutate(n = ifelse(is.na(n), 0, n))
```

Ladybirds:

```{r ladybirds}
n_occ_ladybirds <- calculate_occ_total(db = sqlite_files[2],
                                    table = gbif_download_keys[2],
                                    cols_to_select_bigdata)
n_occ_ladybirds <- left_join(data.frame(year = c(min(n_occ_ladybirds$year):max(n_occ_ladybirds$year)),
                                        stringsAsFactors = FALSE),
                             n_occ_ladybirds,
                  by = "year") %>%
  mutate(n = ifelse(is.na(n), 0, n))
```

Maximum and minimum:

```{r max_min}
extreme_ladybirds <- list("n_max" = max(n_occ_ladybirds$n),
                          "n_min" = min(n_occ_ladybirds$n))

extreme_ladybirds
```

Show number of occurrences of ladybirds per year in Belgium:

```{r}
ggplot(n_occ_ladybirds, aes(year, n)) +
   geom_col() +
  ggtitle("Ladybirds: number of occurrences per year")
```

## Linear approach

The easier way. We can correct the number of occurrences ($n$) by multiplying it by the inverse of the linear function:

$$ f(n) = \frac{0.95}{n_{max}} n + 0.05, n\in (n_{min},n_{max}), 0.05\leq f(x) \leq 1  $$ 

```{r coeff_linear}
curve(1/(0.95*x/extreme_ladybirds$n_max + 0.05), 
      from=0, to=extreme_ladybirds$n_max, xlab="n", ylab="Bias correction")
```

The number of occurrences corrected by bias:

```{r n_occ_}
harmonia_axyridis_corrected <- pres_abs_table %>%
         filter(species == "Harmonia axyridis") %>%
  mutate(n = ifelse(is.na(n), 0, n)) %>%
  mutate(bias = 1/(0.95/extreme_ladybirds$n_max*n + 0.05)) %>%
  mutate(n_corrected = n * bias)
```

Corrected area of occupancy (%):

```{r}
ggplot(harmonia_axyridis_corrected %>%
         filter(presence == 1 & ) %>%
           group_by(year) %>%
           summarize(aoc = n()/nrow(belgium_5grid)*100), 
       aes(year, aoc)) + 
    geom_col() +
    ggtitle(x) +
    labs(x = "year", y = "AOC (%)")
```

