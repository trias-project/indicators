---
title: "Testing segmented regression for the analysis of occurence time series"
author:
  - Toon Van Daele Damiano Oldoni
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    df_print: paged
    theme: yeti
---
  
# Goal 

This document is a test with the segmented regression technique for the analysis of time series of occurence data.

## segmented regression paper (on deseases)

Funk, S., et al. (2013). "Quantifying Trends in Disease Impact to Produce a Consistent and Reproducible Definition of an Emerging Infectious Disease." Plos One 8(8).

## segmented package R

We use the the segmented function from the package with the same name.

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:
  
```{r load_libraries}
library(tidyverse)
library(pander)
library(segmented)
library(strucchange)
library(MASS)
```

```{r define functions}
# 'Apply a simple regression and try adding break points.
#
# '@param df_r data.frame data frame with time series data
# '@return matrix matrix with slopes for each break point. Columns: slope,
# lower ci, upper ci, intercept
segm_regr <- function(df_r){
  cat(spec, " - ", min(df_r$year), " -> ", max(df_r$year), "\n")

  # lm/glm without breakpoints
  lm <- lm(aantal ~ nyear, data = df_r)
  #lm <- glm(aantal ~ nyear, family = poisson, data = df_r)
  #lm <- glm.nb(aantal ~ nyear, data = df_r)

  msm  <- c(lm$coefficients[2], confint(lm)[2,],
            lm$coefficients[1], min(df_r$nyear))
  msm <- rbind(msm, c(rep(NA, 4), max(df_r$nyear)))

  if (nrow(df_r) > 6) {
    myts <- ts(df_r$aantal, start = min(df_r$year), end = max(df_r$year))
    try({bp <- breakpoints(myts ~ 1, h = 2)
    
      if (!is.na(bp$breakpoints)){
        bpy <- df_r$nyear[bp$breakpoints]
        for (bpi in 1:length(bpy)){
          #Try to fit with breakpoints
          try({lm_s1 <- segmented(obj = lm, seg.Z = ~nyear, psi = bpy[1:bpi],
                                  control = seg.control(seed = 31, K = bpi,
                                                        stop.if.error = TRUE))

            msm <- slope(lm_s1)[[1]][,c(1, 4, 5)]
            msm <- cbind(msm,intercept(lm_s1)[[1]][,1])
            msm <- cbind(msm, c(min(df_r$nyear), lm_s1$psi[,2]))
            msm <- rbind(msm, c(rep(NA, 4), max(df_r$nyear)))
          }, silent = FALSE)
        }
      }
    }, silent = FALSE)
  }
  return(msm)
}


# 'ggplot plot object segmented regression
# '
# '@param msm output from segm_regr
# '@param df_r time series data
# '@param minyear minimum x value
# '@param maxyear maximum x value
# '@param maxaantal maximum y value
# '@param printplot boolean print plot to screen 

plot_sr <- function(msm, df_r, minyear, maxyear, maxaantal, printplot = FALSE){

  spec <- as.character(df_r[1,"species"])
  l_year <- max(df_r$year)
  l_aantal <- df_r[df_r$year == l_year, "aantal"]

  g <- ggplot(df_r, aes(x = year, y = aantal)) + geom_point()

  for (i in 1:(nrow(msm) - 1)) {
    sgm_xb <- msm[i, 5]
    sgm_xe <- msm[i + 1, 5]
    sgm_yb <- msm[i, 4] + sgm_xb * msm[i,1]
    sgm_ye <- sgm_yb + msm[i,1] * (sgm_xe - sgm_xb)

    if (msm[i,2] > 0) {mycol = "red"}else{mycol = "green"}
    xb <- sgm_xb * attr(df_r$nyear, 'scaled:scale') + attr(df_r$nyear, 'scaled:center')
    xe <- sgm_xe * attr(df_r$nyear, 'scaled:scale') + attr(df_r$nyear, 'scaled:center')
    g <- g + geom_segment(x = xb, y = sgm_yb, xend = xe, yend = sgm_ye, colour = mycol)  # y has to be exp() when using loglink
  }

  g <- g + coord_cartesian(xlim = c(minyear, maxyear), ylim = c(0, maxaantal)) +
    ggtitle(paste0(spec, "_", l_year, "_", l_aantal))

  ggsave(filename = paste0("../figures/spec_", spec, "_", l_year, ".png"), plot = g)
  if (printplot == TRUE) plot(g)

}
```

# Load data

```{r load data}
filename <- "../data/input/segmented_regression_test_2018_12_06.RDS"
df <- readRDS(filename)
```

filename: `r filename`

```{r summary, results='asis'}
#pandoc.table(summary(df))
df
```

List of species for the analysis:

```{r specieslist, results='asis'}
speclist <- unique(df$species)
#pandoc.table(speclist)
speclist
```

Plot of raw time series as it's downloaded from GBIF

```{r raw_time_series}
df %>%
  group_by(species, year) %>%
  summarize(aantal = n()) %>%
  ggplot(aes(x = year, y = aantal)) + geom_line(color = "dark grey") + geom_point() + 
  facet_wrap(~species, scales = "free")
```


We do some minor cleaning:
- Data from the last two years (2017 & 2018) are not complete. Probably due to the delay between  observation and the GBIF database. We'll have to think about how to handle this. for now we ignore the data from 2017 and 2018.
- The single data point in 1905 is not useful. We only consider data after 1980.
- no observation (NA) should be 0. (no distinction between NA and 0 observations)

```{r data cleaning}
df <- filter(df, year > 1980 & year < 2017) %>%
    group_by(species, year) %>%
    summarize(aantal = n()) %>%
    spread(key = species, value = aantal) %>%
    gather(key = species, value = aantal, -year) %>%
    mutate_all(funs(replace(., is.na(.), 0)))
df$em <- "unkown"

df %>%
  group_by(species) %>%
  ggplot(aes(x = year, y = aantal)) + geom_line(color = "dark grey") + geom_point() +
  facet_wrap(~species, scales = "free")
```

# Run the segmented regression algoritm

for each species and for increasing time series

```{r}
#loop through all species in speclist
for (spec in speclist) {
  # select the species  
  df_s <- filter(df, species == spec)

  # Some info needed to assure all plots for one species are the same size
  maxyear <- max(df_s$year)
  minyear <- min(df_s$year)
  maxaantal <- max(df_s$aantal)
  
  # Create an increasing time series starting from three data points
  # (when to start is to be decided)
  for (i in 3:nrow(df_s)) {
  
    df_r <- top_n(df_s, -i, year)
    df_r$nyear <- scale(df_r$year)
    msm <- segm_regr(df_r)
    
    plot_sr(msm, df_r, minyear, maxyear, maxaantal)
    
    df[df$year == max(df_r$year) & df$species == spec, "em"] <- sign(msm[nrow(msm) - 1,2])
  }
}
```

## Result plot

The color of the dot indicates how the latest segment is evaluated (emerging or not emerging) for a time series up till this dot.

```{r plot_results}
group.colors <- c("1" = "red", "0" = "green", "-1" = "green", "unkown" = "black")

df %>%
  group_by(species) %>%
  ggplot(aes(x = year, y = aantal)) + geom_line(color = "dark grey") + 
  geom_point(aes(group = em, colour = em)) + 
  scale_color_manual(values = group.colors) +
  facet_wrap(~species, scales = "free")
```


