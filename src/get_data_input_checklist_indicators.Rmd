---
title: "Checklist-based indicators of Invasive Alien Species"
author:
- Damiano Oldoni
- Add your name
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This document describes how to build indicators of Invasive Alien Species based on checklist data. In particular, the following indicators are taken into account:

1. number of new introductions of alien species per year in Belgium (see GitHub issue [#17](https://github.com/trias-project/pipeline/issues/17))
2. pathways associated with alien species introductions (see GitHub isue [#19](https://github.com/trias-project/pipeline/issues/19))
3. cumulative number of alien species (see GitHub issue [#20](https://github.com/trias-project/pipeline/issues/20))

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Install `trias` package:

```{r install_packages}
devtools::install_github("trias-project/trias@add_functions_checklist_indicators")
```


Load libraries:

```{r load_libraries}
# Tidyverse packages
library(tidyr)
library(dplyr)
library(magrittr)
library(stringr)
library(readr)
# GBIF related packages
library(rgbif)
# project package
library(trias)
#other pckages
library(lazyeval)
```

# Get data

## Get taxonomic data

Get taxa from the published unified checklist, the [*Global Register of Introduced and Invasive Species - Belgium*](https://www.gbif.org/dataset/6d9e952f-948c-4483-9807-575348147c7e):

```{r get_data_unified_checklist}
taxa <- name_usage(datasetKey = "6d9e952f-948c-4483-9807-575348147c7e",
                   return = "data",
                   limit = 10000) %>%
  filter(origin == "SOURCE")
```

Select columns we are interested to:

```{r select_cols_interest}
checklist_info <- c("key", "nubKey", "scientificName", "datasetKey")
taxa <-
  taxa %>%
  select(one_of(checklist_info))
```


### Distribution

Extract distribution information

```{r retrieve_distribution_information}
distribution <- data.frame(key = taxon_keys) %>%
  rowwise() %>%
  do_(interp(~ as.data.frame(rgbif::name_usage(key = .$key,
                                               return = "data",
                                               data = "distribution")))) %>% 
  select(-source)
head(distribution)
```

### Description

Extract description information

```{r retrieve_description_information}
description <- data.frame(key = taxon_keys) %>%
  rowwise() %>%
  do_(interp(~ as.data.frame(rgbif::name_usage(key = .$key,
                                               return = "data",
                                               data = "description"))))
description %<>% select(-c(key, language, source))
description %<>% ungroup()
head(description, n = 10)
```

Contrarily to distribution information, description contains a column  `type` with the following descriptors: 

```{r}
description %>% distinct(type)
descriptors <- description %>% distinct(type) %>% pull()
```
We would like to *tidy* this data.frame, thus having different descriptors as different columns. Unfortunately `dplyr::spread(key, value)` doesn't work due to *duplicates*, i.e. keys with more than one value, for example:

```{r duplicates_issue_spread}
description %>% filter(taxonKey == 141264585 & type == "native range")
```

A more complex strategy has been found:

```{r tidy_description}
change_colname <- function(df, new_colname){
  df %>% 
    rename(!!new_colname := description) %>%
    select(-type)
}

description_tidy <- 
  purrr::map(descriptors, function(x) description %>% filter(type == x)) %>%
  purrr::map2(descriptors, ~ change_colname(.x, .y)) %>%
  purrr::reduce(dplyr::full_join, by = "taxonKey")
head(description_tidy)
```

The chunk code above should be wrapped in a function: Peter Desmet proposed the name `spread_with_duplicates`. It could be put in project package, `trias`, or be part of `tidyr` package eventually. See GitHub issue [#16](https://github.com/trias-project/trias/issues/16).

### Species profile

Extract species profile

```{r retrieve_species_profile_information}
speciesProfiles <- data.frame(key = taxon_keys) %>%
  rowwise() %>%
  do_(interp(~ as.data.frame(rgbif::name_usage(key = .$key,
                                               return = "data",
                                               data = "speciesProfiles"))))
head(speciesProfiles)
```

### Merge data

Merge all retrieved informations

```{r merge_extensions_information}
merged_extensions <- full_join(distribution,
                               description_tidy,
                               speciesProfiles,
                               by = "taxonKey")

merged_info <- left_join(combined_taxon_info, merged_extensions,
                         by = c("key" = "taxonKey"))
```

## Filter invasive alien species

Filter species by:

1. invasion stage (`establishmentMeans` equal to one of `INTRODUCED`,  `NATURALISED`, `INVASIVE`, `ASSISTED COLONISATION`) see GitHub issue [#28](https://github.com/trias-project/pipeline/issues/28#issuecomment-382036510)
2. presence status (`status` not equal to `DOUBTFUL`, `ABSENT`, `EXCLUDED` or `EXTINCT`) see GitHugb issue [#26](https://github.com/trias-project/pipeline/issues/26#issuecomment-382036007)
3. presence in Belgium (`country` equal to `BE`)

```{r filter_by_establishmentMeans}
merged_info %<>%
  filter(establishmentMeans %in% c("INTRODUCED", "NATURALISED", "INVASIVE",
                                   "ASSISTED COLONISATION"),
         !status %in% c("DOUBTFUL", "ABSENT", "EXCLUDED", "EXTINCT"),
         country == "BE")
```

## Tidy data

Some columns should be splitted in order to make the data.frame completely tidy: `temporal` and `pathway`.

### Split column `temporal`

The column `temporal` contains one or two datums

```{r example_temporal, echo = FALSE}
merged_info %>% 
  select(key, temporal) %>% 
  distinct() %>% 
  filter(!is.na(temporal)) %>%
  head()
```

In case there are two datums, we split them in `first_observed` and `last_observed`. If only a datum is present, then it is used for both  `first_observed`and `last_observed` as suggested [here]().

```{r split_temporal}
merged_info %<>% separate(col = temporal,
                          sep = "/",
                          into = c("first_observed", "last_observed"),
                          convert = TRUE,
                          fill = "right",
                          remove = TRUE) %>%
  mutate(last_observed = ifelse(is.na(last_observed),
                          first_observed,
                          last_observed))
```

As example

```{r example_split_temporal, echo = FALSE}
merged_info %>% 
  filter(locality == "Belgium") %>% 
  select(key, first_observed, last_observed) %>%
  distinct() %>%
  filter(!is.na(first_observed) & !is.na(last_observed)) %>%
  head()
```

### Split column `pathway`

The column `pathway` contains a prefix, `cbd_2014_pathway:` and two different pathway levels divided by symbol `_`

```{r pathway_levels_example, echo = FALSE}
merged_info %>% distinct(pathway) %>% filter(!is.na(pathway)) %>% head()
```

We split this column in `pathway_level1` and `pathway_level2`

```{r split_pathway}
merged_info %<>% rowwise() %>%
  mutate(pathway_level1 = 
           str_split_fixed(
             str_split(pathway,
                       pattern = "pathway:")[[1]][2],
             pattern = "_", n = 2)[[1]][1],
         pathway_level2 = 
           str_split_fixed(
             str_split(pathway,pattern = "pathway:")[[1]][2],
             pattern = "_", n = 2)[[2]][1]) %>%
  ungroup() %>%
  select(-pathway) 
```

As example:

```{r example_split_pathway, echo = FALSE}
merged_info %>% 
  distinct(pathway_level1, pathway_level2) %>%
  filter(!is.na(pathway_level1) & !is.na(pathway_level2)) %>%
  head()
```

## Save data output

The information in `merged_info` is ready to be saved in folder `\data\interim`:

```{r save_data_output, eval=FALSE}
write_tsv(x = merged_info, 
          path = "../data/interim/test_data_output_checklist_indicators.tsv")
```

And be used as start point for building indicators.
