---
title: "Get input data for checklist-based indicators"
author:
- Damiano Oldoni
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This document describes how to get and manipulate data from [unified checklist](https://www.gbif.org/dataset/6d9e952f-948c-4483-9807-575348147c7e) for checklist-based indicators.

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r load_libraries}
library(tidyverse)      # To do data science
library(tidylog)        # To provide feedback on dplyr functions
library(here)           # To find files
library(rgbif)          # To get taxa from publisehd unified checklist
library(trias)          # To get indicator functionalities
```

# Get data

## Get taxonomic data

Get taxa from the published unified checklist, the [*Global Register of Introduced and Invasive Species - Belgium*](https://www.gbif.org/dataset/6d9e952f-948c-4483-9807-575348147c7e):

```{r get_data_unified_checklist}
taxa <- name_usage(datasetKey = "6d9e952f-948c-4483-9807-575348147c7e",
                   return = "data",
                   limit = 10000) %>%
  filter(origin == "SOURCE")
```

Select columns we are interested to:

```{r select_cols_interest}
checklist_info <- c("key", "nubKey", "scientificName", "datasetKey",
                    "canonicalName", "species", "genus", "family", 
                    "order", "class", "phylum", "kingdom",	
                    "rank", "speciesKey", "taxonomicStatus", 	
                    "acceptedKey", "accepted")
taxa <-
  taxa %>%
  select(one_of(checklist_info))
```


## Get distribution

Extract distribution information

```{r retrieve_distribution_information, cache=TRUE}
distribution <- taxa %>%
  pull(key) %>%
  map_dfr(~ name_usage(.,
                     return = "data",
                     data = "distribution")) %>% 
  select(-source)
head(distribution)
```

## Get description

Extract description information

```{r retrieve_description_information, cache=TRUE}
description <- taxa %>%
  pull(key) %>%
  map_dfr(~ name_usage(.,
                     return = "data",
                     data = "description")) %>% 
  select(-c(key, language, source))
head(description, n = 10)
```

Description contains a column `type` with the following descriptors: 

```{r descriptors}
description %>% distinct(type)
```

We are interested to the following types:

```{r define_types}
types <- c("invasion stage", 
           "native range", 
           "degree of establishment", 
           "pathway")
```

We filter out the other types:

```{r select_types}
description <- 
  description %>%
  filter(type %in% types)
```

We *tidy* this data.frame, thus having different descriptors as different columns:

```{r tidy_description}
description <- 
  description %>%
  as_tibble() %>%
  pivot_wider(names_from = type,
              values_from = description,
              values_fn = list(name=list)) %>%
  unnest_longer(types[1]) %>%
  unnest_longer(types[2]) %>%
  unnest_longer(types[3]) %>%
  unnest_longer(types[4])
description %>% head(n = 20)
```

We also clean column names by standardizing column names:

```{r standardize_colnames}
description <-
  description %>%
  janitor::clean_names("lower_camel")
names(description)
```

### Mapping `degree of establishment`

Values in column `degreeOfEstablishment`:

```{r degree_of_establishment}
description %>%
  distinct(degreeOfEstablishment)
```

We map them as follows:

```{r mapping_degree_of_establishment}
description <-
  description %>%
  mutate(degreeOfEstablishment = recode(
    degreeOfEstablishment,
    "captive (blackburn_2011:B1)" = "captive",
    "blackburn_et_al_2011:B2" = "cultivated",
    "released (blackburn_2011:B3)" = "released",
    "blackburn_et_al_2011:C0" = "failing",
    "casual (blackburn_2011:C1)" = "casual",
    "reproducing (blackburn_2011:C2)" = "reproducing",
    "established (blackburn_2011:C3)" = "established",
    "blackburn_et_al_2011:C3" = "established",
    "colonizing (blackburn_2011:D1)" = "colonizing",
    "blackburn_et_al_2011:D2" = "invasive",
    "blackburn_et_al_2011:E" = "widespreadInvasive"
))
```

## Species profile

Extract species profile

```{r retrieve_species_profile_information, cache=TRUE}
speciesProfiles <- taxa %>%
  pull(key) %>%
  map_dfr(~ name_usage(.,
                     return = "data",
                     data = "speciesProfiles"))
head(speciesProfiles)
```

## Merge data

Merge distribution, description and species profile information:

```{r merge_extensions_information}
merged_extensions <- 
  full_join(distribution,
            description,
            by = "taxonKey") %>%
  full_join(speciesProfiles,
            by = "taxonKey")

merged_info <- left_join(taxa, merged_extensions,
                         by = c("key" = "taxonKey"))
head(merged_extensions)
```

## Tidy data

Some columns should be splitted in order to make the data.frame completely tidy: `temporal` and `pathway`.

### Split column `temporal`

The column `temporal` contains one or two datums:

```{r example_temporal, echo = FALSE}
merged_info %>% 
  select(key, temporal) %>% 
  distinct() %>% 
  filter(!is.na(temporal)) %>%
  head()
```

In case there are two datums, we split them in `firstObserved` and `lastObserved`. If only a datum is present, then it is used for both  `firstObserved`and `lastObserved`.

```{r split_temporal}
merged_info <-
  merged_info %>% separate(col = temporal,
                           sep = "/",
                           into = c("firstObserved", "lastObserved"),
                           convert = TRUE,
                           fill = "right",
                           remove = TRUE) %>%
  mutate(lastObserved = ifelse(is.na(lastObserved),
                          firstObserved,
                          lastObserved))
```

An example:

```{r example_split_temporal, echo = FALSE}
merged_info %>% 
  filter(locality == "Belgium") %>% 
  select(key, firstObserved, lastObserved) %>%
  distinct() %>%
  filter(!is.na(firstObserved) & !is.na(lastObserved)) %>%
  head(10)
```

### Split column `pathway`

The column `pathway` contains a prefix, `cbd_2014_pathway:` and two different pathway levels divided by symbol `_` (Note: this is not valid for pathway `natural_dispersal`, which should not be divided in two levels)

```{r pathway_levels_example, echo = FALSE}
merged_info %>% distinct(pathway) %>% filter(!is.na(pathway)) %>% head()
```

We split this column in `pathwayLevel1` and `pathwayLevel2`

```{r split_pathway}
merged_info <-
  merged_info %>% 
  rowwise() %>%
  mutate(pathwayLevel1 = 
           str_split_fixed(
             str_split(pathway,
                       pattern = "pathway:")[[1]][2],
             pattern = "_", n = 2)[[1]][1],
         pathwayLevel2 = 
           str_split_fixed(
             str_split(pathway,pattern = "pathway:")[[1]][2],
             pattern = "_", n = 2)[[2]][1]) %>%
  ungroup() %>%
  mutate(pathwayLevel1 = ifelse(
    pathwayLevel1 == "natural",
    "natural_dispersal",
    pathwayLevel1)) %>%
  mutate(pathwayLevel2 = ifelse(
    pathwayLevel2 == "dispersal",
    "",
    pathwayLevel2)) %>%
  select(-pathway)
```

Full mapping:

```{r example_split_pathway, echo = FALSE}
merged_info %>% 
  distinct(pathwayLevel1, pathwayLevel2)
```

## Save data output

The data.frame `merged_info` is saved as output file:

```{r save_data_output}
write_tsv(merged_info, 
          path = here::here("data", 
                            "interim",
                            "data_input_checklist_indicators.tsv"),
          na = ""
)
```

This file is the start point for building checklist-based indicators.
