---
title: "Effects of grid size on (Area Of) Occupancy"
author:
  - Damiano Oldoni
date: "`Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---
  
# Goal 

This document is an ongoing research studying the effects of grid size on calculating the Area of Occupancy (AOO) and the related Occupancy, which is the AOO divided by the total area. Geographic coordinate uncertainty in occurrence data will also be tackled.

## Grid size 

We divide Belgium based on UTM grids. We use three grids as provided by European Environment Agency via this [link](https://www.eea.europa.eu/data-and-maps/data/eea-reference-grids-2/gis-files/belgium-shapefile).  Cell sizes available: 1x1km, 10x10km and 100x100km. The 1x1km grid size provides a resolution which is much finer than the resolution of (part of) the available occurrence data. On the other side, the 10x10km grid size is not so informative, specially for a small country like Belgium. The 100x100km grid size will be used as kind of (saturated) reference. In this document we will provide more insights into the effects of grid cell size on the (Area Of) Occupancy.

## Geographic coordinate uncertainty and aggregated data

Using geographic coordinate uncertainty means conceiving occurrence data as circles instead of points. Such circles can intersect several grid cells. The question how to assign the occurrence data to the grid cells arises. We can assign an occurrence point to :

1. the centre. This method is equivalent to not taking into account uncertainty: a very simple method but a bias could occurr due to the presence of aggregated data. 
2. a random point in the circle. It is the best way to handle uncertainty, although computationally demanding for large occurrence dataset.

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:
  
```{r load_libraries}
# GBIF package
library(rgbif)
# Spatial packages
# installation via devtools::install_github("r-spatial/sf") suggested
library(sf) 
# visualization package
library(leaflet)
# Downscaling package
library(downscale)
# multiprocessor package
library(multidplyr)
# Tidyverse packages
library(tidyverse)
```

# Define species under study

We are interested in the following alien species:
  
species | kingdom | GBIF backbone key
--- | --- | ---
Baccharis halimifolia | Plantae | 3129663
Impatiens glandulifera | Plantae | 2891770
Impatiens capensis | Plantae | 2891774
Hydrocotyle ranunculoides | Plantae | 7978544
Branta canadensis | Animalia | 5232437
Harmonia axyridis | Animalia | 4989904

limited to Belgium (`countryCode = BE`).

# Import data 

## Import occurrence data

A download has been triggered. Download key: `"0012078-181003121212138"`.

```{r get_dwc_hascoord}
gbif_key <- "0012078-181003121212138"
occ_df_file <- paste0("../data/interim/occ_df_", 
                                          gbif_key, ".csv")
# downloaded zip file is in ./data/interim/
file_path <- paste0("../data/interim/")
if (!file.exists(file_path))
  dir.create(file_path)
if (!file.exists(occ_df_file)){
  occ <- occ_download_get(key = gbif_key, overwrite = TRUE, path = file_path)
fn <- "occurrence.txt"
unzip(zipfile = occ, files = fn,
      exdir = "../data/interim/.")
file.rename(from = "../data/interim/occurrence.txt", 
            to = occ_df_file)
}
```

Import text file to R:
  
```{r import_to_R_df2}
occ_df <- read_delim(
  file = occ_df_file, delim = "\t",
  escape_double = FALSE, trim_ws = TRUE)
```

Remove eventually misleading parsing failures:

```{r remove_parsing_failures}
occ_df <- occ_df %>%
   filter(species != "2986")
```

Species:

```{r species}
species_df <- occ_df %>%
  distinct(species, speciesKey)
species_df
```


Number of occurrences per species:
  
```{r n_occ_per_species_query_rgbif_coord}
count_occ_df <- occ_df %>%
  group_by(speciesKey, species) %>%
  count() %>%
  arrange(desc(n))
count_occ_df
```

## Pre-process occurrence data

### Remove specimen

Specimen are not occurrence data we are interested to:

```{r show_specimen}
occ_df %>%
  group_by(basisOfRecord) %>%
  count()
```

We retain only human observations:

```{r}
occ_df <- occ_df %>%
  filter(basisOfRecord == "HUMAN_OBSERVATION")
```

## Remove occurrence related to absence

Some occurrences have `occurrenceStatus` equal to `absent`:

```{r show_summary_occ_Status}
occ_df %>%
  group_by(occurrenceStatus) %>%
  count()
```

These occurrence points are related to following species:

```{r summary_species_absency}
occ_df %>%
  filter(occurrenceStatus == "absent") %>%
  group_by(speciesKey, species, occurrenceStatus) %>%
  count()
```

We remove them:

```{r remove_absence}
occ_df <- occ_df %>%
  filter(!occurrenceStatus %in% c("absent"))
```


## Check temporal information

Occurrence data without temporal information cannot be handled. Overview:

```{r temporal_info}
occ_df %>%
  filter(is.na(year)) %>%
  group_by(speciesKey, species, datasetKey, datasetName) %>%
  count()
```

We remove them:

```{r remove_occ_without_time}
occ_df <- occ_df %>%
  filter(!is.na(year))
```

### Check presence of coordinates

Occurrences without coordinates:

```{r}
occ_df %>%
  filter(is.na(decimalLatitude) | is.na(decimalLongitude)) %>%
  group_by(speciesKey, species) %>%
  count()
```

We remove them:

```{r filter_valid_geo_coords}
occ_df <- occ_df %>%
  filter(!is.na(decimalLatitude) & !is.na(decimalLongitude))
```

Note: this filter is equivalent of a GBIF download query containing the additional parameter `hasCoordinate = TRUE`.

Number of occurrences per species left:
  
```{r _n_occ_per_species_query_rgbif_coord}
count_occ_df <- occ_df %>%
  group_by(speciesKey, species) %>%
  count()
count_occ_df
```

### Handle data without spatial uncertainty

Uncertainty on position is given in `coordinateUncertaintyInMeters` while in `verbatimCoordinateSystem` we can get details about the coordinate system used while collecting data:

```{r overview_unc_verbatimCRS}
occ_df %>% 
  group_by(coordinateUncertaintyInMeters, verbatimCoordinateSystem) %>%
  count() %>%
  arrange(desc(n))
```

Overview of occurrence data without coordinate uncertainty:

```{r}
occ_df %>% 
  filter(is.na(coordinateUncertaintyInMeters)) %>%
  group_by(datasetKey, datasetName, speciesKey, species) %>%
  count() %>%
  arrange(desc(n)) %>%
  ungroup() %>%
  select(datasetName, species, n, everything())
```

In some cases, based on the dataset and the coordinate system information, we can assign the right uncertainty. However, this approach is not machine-based, very time consuming and not feasable at large scales. A possible solution is the following: **we assign a default uncertainty of 1000 meters to occurrence data without uncertainty**.

```{r assign_default_1000m_uncertainty}
occ_df <- occ_df %>%
  mutate(coordinateUncertaintyInMeters = ifelse(
    is.na(coordinateUncertaintyInMeters), 1000.0, coordinateUncertaintyInMeters)
  )
```

Final overview of the most common coordinate uncertainty for each species and year, the _mode_:

```{r mode_coord_unc}
calc_mode <- function(data) {
  data %>% 
    group_by(coordinateUncertaintyInMeters) %>%
    count() %>%
    arrange(desc(n)) %>%
    ungroup() %>%
    slice(1) %>%
    pull(coordinateUncertaintyInMeters)
}

mode_unc_df <- occ_df %>%
  group_by(species, speciesKey, year) %>%
  nest() %>%
  mutate(mode_uncertainty = map_dbl(data, calc_mode)) %>%
  select(-data) %>%
  arrange(species, year)
mode_unc_df
```

## Import grid data

We import UTM grid data at three scales: 1 by 1 km, 5 by 5 km  and 10 km by 10 km. As said in introduction, the 5 by 5 km is not a standard resolution: it is used only within INBO Flemish research. All grids have CRS (Coordinate Reference System) equal to _Belge Lambert 1972_:

```{r import_grids_5km}
grids <- list(grid_1x1km = "utm1_bel", 
              grid_10x10km = "utm10_bel", 
              grid_100x100km = "utm100_bel")
belgium_grids <- map(grids, ~ st_read(paste0("../data/external/", .)))
crs_grid <- st_crs(belgium_grids[["grid_1x1km"]])
crs_grid
```

Total area of the grids in square meters:

```{r}
total_areas <- map(belgium_grids, function(x) as.numeric(sum(st_area(x))))
total_areas
```

and mean cell size in meters:

```{r mean_cell_size}
cell_sizes <- map(belgium_grids, function(x) as.numeric(mean(st_area(x))))
cell_sizes
```

# Calculate (Area of) Occupancy

## Assign occurrence to centre (no use of uncertainty values)

We assign the occurrence data to the centre of the circle formed by taking the `coordinateUncertaintyInMeters` as radius and the columns columns `decimalLongitude` - `decimalLatitude` as centre. We use the latter ones to create such points, thus discarding information about geographic coordinate uncertainty. Notice that GBIF occurrence data use WGS84 projection:

```{r set_crs_GBIF_data}
# CRS used by GBIF
wgs_84 <- st_crs("+init=epsg:4326") 
```

Create points and convert them to grid projection:

```{r from_df_to_points}
occ_pts <- st_as_sf(occ_df, coords = c('decimalLongitude', 'decimalLatitude'), 
                    crs = wgs_84)
occ_pts <- st_transform(occ_pts, crs_grid)
```

Intersect points and grids:

```{r intersect}
points_on_grids <- map(belgium_grids, st_intersection, occ_pts)
```

Only grid cells containing at least one point are present. 

We calculate the number of occurrences per cell and assign 1 (presence) to them. This step can take long due to the high number of cells of the grid with 1x1km resolution:

```{r pres_abs}
pres_table <- map(points_on_grids, function(x) {
  part_year <- partition (x, CELLCODE) 
  pres_year <- part_year %>%
  group_by(speciesKey, year) %>%
  summarise(dplyr::n()) %>%
  as.tibble(pres_year) %>%
  ungroup() %>%
  rename("n_occs" = "dplyr::n()") %>%
  filter(n_occs > 0) %>%
  mutate(presence = 1) %>%
  left_join(species_df, by = "speciesKey") %>%
  select(speciesKey, species, everything())
  return(pres_year)
})
```

For each grid resolution species and year, we calculate the Area Of Occupancy (AOO) and the Occupancy (AOO divided by total grid area):

```{r AOO_calculate}
aoo <- pmap(list(pres_table, belgium_grids, total_areas, cell_sizes),
            function(presence_df, grid, total_area, cell_size) {
              presence_df %>%
                group_by(species, speciesKey, year) %>% 
                summarize(aoo = n() *cell_size,
                          n_occs = sum(n_occs)) %>%
                ungroup() %>%
                mutate(occupancy = aoo / total_area,
                       cell_area = cell_size)
})
```

AOO plot:

```{r AOO_plot}
map2(aoo, names(aoo), function(grid, name_grid) {
    ggplot(grid) + 
    aes(x = year, y = aoo/10^6) +
    facet_wrap(~ species) +
    geom_col() +
    labs(x = "year", y = "AOO (km2)") +
    ggtitle(name_grid)
})
```

Occupancy plot:

```{r occupancy_plot}
map2(aoo, names(aoo), function(grid, name_grid) {
    ggplot(grid) + 
    aes(x = year, y = occupancy) +
    facet_wrap(~ species) +
    geom_col() +
    labs(x = "year", y = "occupancy") +
    ggtitle(name_grid)
})
```

We compare the AOO calculated using different grid cell size:

```{r aoo_compare_tidy_df}
aoo_compare_tidy <- map2_dfr(aoo, names(aoo),
                             function(df, grid_name) {
  df %>% mutate(grid_size = grid_name)
})
```

Plot for each species:

```{r plot_AOO_different_grid_cell_sizes}
map(species_df$species, 
    function(x){
      ggplot(aoo_compare_tidy %>%
         filter(species == x),
       aes(x = year, y = aoo/(10^6), color = grid_size)) +
  geom_col(alpha=0.5, fill = "white", position = "dodge") +
  labs(x= "year", y = "AOO") +
  ggtitle(paste0(x,". Area Of Occupancy (AOO) km2"))
})
```

As expected the AOO increases by increasing the grid cell size. We plot the logarithm of occupancy and the logarithm of cell area for period 2005 - 2010:

```{r}
years <- aoo_compare_tidy %>%
  filter(year >= 2005 & year <= 2010) %>%
  distinct(year) %>%
  pull()
map(years, function(y) {
  ggplot(aoo_compare_tidy %>%
           filter(year == y), 
       aes(x = log(cell_area), y = log(occupancy), color = species)) +
    geom_point() + 
    geom_line() + 
    labs(x = "log(area)", y = "log(occupancy)") +
    ggtitle(y)
})
```

We can see that no signs of saturation (horizonta line) although endemism surely occurs for species-year combination with very few occurrences (see Azaele et al., 2012 and  `vignette("Upgraining", package = "downscale")`). On the other hand, mapping coarse occurrence data with a finer grid tends theoretically to uncorrect occupancy at such resolution: underestimation will occurr especially if data are aggregated.

# Solution 1: downscaling

Given a coordinate uncertainty $\Delta r$, any grid with cell with side $l < 2 \Delta r$ would be too fine. If we aim to calculate AOO at a resolution of 1km we should apply downscaling techniques.

# Solution 2: use uncertainty on occurrence data

In this chapter we use information about coordinate uncertainty and conceive occurrence data as circles, with `decimalLongitude` and `decimalLatitude` as centre and radius equal to `coordinateUncertaintyInMeters`.

```{r create_circles}
occ_circles <- st_buffer(occ_pts, 
                         dist = occ_pts$coordinateUncertaintyInMeters,
                         nQuadSegs = 6)
```

A preview leaflet map by using the grid with cell size 10x10km and occurrence data of species _Hydrocotyle ranunculoides_ from 2000:

```{r leaflet}
data_on_leaflet <- occ_circles %>%
  filter(species == "Hydrocotyle ranunculoides") %>%
  filter(year >= 2015) %>%
  st_transform(wgs_84)

mapt <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = belgium_grids$grid_10x10km %>%
                st_transform(wgs_84),
              weight = 1, opacity = 0.5, fillOpacity = 0.1) %>%
  addPolygons(data = data_on_leaflet,
              weight = 1, opacity = 0.4, fillOpacity = 0.5)
mapt
```

Some occurrence data are quite coarse and geographically aggregated: they are assigned to same coordinates, thus resulting in darker points on map. A way to solve such issue and at the same time to take into account the coordinate uncertainty, we assign the occurrence data to a point randomly chosen within the circle. Note: this step can take long:

```{r assign_pts_randomly_within_circle}
get_random_pt <- function(x) {
  random_pt <- st_sample(x , size = 1, type = "random")
  while (length(random_pt) == 0) {
    random_pt <- st_sample(x , size = 1, type = "random")
  }
  return(random_pt)
}

random_pts <- map(st_geometry(occ_circles), get_random_pt)
random_pts <- st_sfc(unlist(random_pts, recursive = FALSE), crs = crs_grid)
```

Assign these new points to the occurrence data:

```{r assign_pts_to_circles_randomize}
occ_pts_randomize <- st_sf(data.frame(occ_df, geom = random_pts))
```

Preview:

```{r check_randomize}
n_pts <- 50
preview_pts_circles <- occ_pts_randomize[1:n_pts,]

mapt <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = belgium_grids$grid_10x10km %>%
                st_transform(wgs_84),
              weight = 1, opacity = 0.5, fillOpacity = 0.1) %>%
  addCircleMarkers(data = preview_pts_circles %>%
                     st_transform(wgs_84), 
                   radius = 2, color = "red") %>%
  addPolygons(data = occ_circles[1:n_pts,] %>%
                st_transform(wgs_84),
              weight = 1, opacity = 0.3, fillOpacity = 0.3)
  
mapt
```

We can now repeat the same procedure followed in #calculate-(area-of)-occupancy. First, intersect these new points and grids:

```{r intersect_randomize}
points_on_grids_randomize <- map(belgium_grids, st_intersection, occ_pts_randomize)
```

Only grid cells containing at least one point are present. 

We calculate the number of occurrences per cell and assign 1 (presence) to them. This step can take long due to the high number of cells of the grid with 1x1km resolution:

```{r pres_abs_randomize}
pres_table_randomize <- map(points_on_grids_randomize, function(x) {
  part_year <- partition (x, CELLCODE) 
  pres_year <- part_year %>%
  group_by(speciesKey, year) %>%
  summarise(dplyr::n()) %>%
  as.tibble(pres_year) %>%
  ungroup() %>%
  rename("n_occs" = "dplyr::n()") %>%
  filter(n_occs > 0) %>%
  mutate(presence = 1) %>%
  left_join(species_df, by = "speciesKey") %>%
  select(speciesKey, species, everything())
  return(pres_year)
})
```

For each grid resolution species and year, we calculate the Area Of Occupancy (AOO) and the Occupancy (AOO divided by total grid area):

```{r AOO_calculate_randomize}
aoo_randomize <- pmap(list(pres_table_randomize, belgium_grids, total_areas, cell_sizes),
            function(presence_df, grid, total_area, cell_size) {
              presence_df %>%
                group_by(species, speciesKey, year) %>% 
                summarize(aoo = n() * cell_size,
                          n_occs = sum(n_occs)) %>%
                ungroup() %>%
                mutate(occupancy = aoo / total_area,
                       cell_area = cell_size)
})
```

The new AOO plot:

```{r AOO_plot_randomize}
map2(aoo_randomize, names(aoo_randomize), function(grid, name_grid) {
    ggplot(grid) + 
    aes(x = year, y = aoo/10^6) +
    facet_wrap(~ species) +
    geom_col() +
    labs(x = "year", y = "AOO (km2)") +
    ggtitle(name_grid)
})
```

Occupancy plot:

```{r occupancy_plot_randomize}
map2(aoo_randomize, names(aoo_randomize), function(grid, name_grid) {
    ggplot(grid) + 
    aes(x = year, y = occupancy) +
    facet_wrap(~ species) +
    geom_col() +
    labs(x = "year", y = "occupancy") +
    ggtitle(name_grid)
})
```

We compare the AOO calculated using different grid cell size:

```{r aoo_compare_tidy_df_randomize}
aoo_compare_tidy_randomize <- map2_dfr(aoo_randomize, names(aoo_randomize),
                             function(df, grid_name) {
  df %>% mutate(grid_size = grid_name)
})
```

Again, AOO increases by increasing the grid cell size. We plot the logarithm of occupancy and the logarithm of cell area for period 2005 - 2010:

```{r}
years <- aoo_compare_tidy_randomize %>%
  filter(year >= 2005 & year <= 2010) %>%
  distinct(year) %>%
  pull()
map(years, function(y) {
  ggplot(aoo_compare_tidy %>%
           filter(year == y), 
       aes(x = log(cell_area), y = log(occupancy), color = species)) +
    geom_point() + 
    geom_line() + 
    labs(x = "log(area)", y = "log(occupancy)") +
    ggtitle(y)
})
```








# Final summary

We can now summarize the results for comparison.

```{r summarize_results}
aoo_compare_tidy_sum <- aoo_compare_tidy %>%
  rename("aoo_unc" = "aoo",
         "occupancy_unc" = "occupancy") %>% 
  select(species, speciesKey, year, n_occs, occupancy_unc, grid_size) %>%
  spread(key = grid_size,
         value = occupancy_unc)
aoo_compare_tidy_randomize_sum <- aoo_compare_tidy_randomize %>%
  rename("aoo_unc" = "aoo",
         "occupancy_unc" = "occupancy") %>% 
  filter(grid_size == "grid_100x100km") %>%
  select(species, speciesKey, year, n_occs, occupancy_unc, grid_size) %>%
  spread(key = grid_size,
         value = occupancy_unc) %>%
  rename("grid_100x100km_uncertainty" = "grid_100x100km")
aoo_summary <- aoo_compare_tidy_sum %>%
  inner_join(aoo_compare_tidy_randomize_sum)
aoo_summary
```

Plot differences between different methods:

```{r differences}
ggplot(aoo_summary, 
       aes(x = year, 
           y = (grid_100x100km_uncertainty - grid_100x100km)/grid_100x100km*100)) + 
  geom_col() +
  facet_wrap(~ species) +
  ylab("Relative increase in occupancy (%)") +
  xlab("year") +
  ggtitle("Occupancy: effect of taking into account uncertainty")
```


# Effect of grid cell on (Area of) Occupancy



Find the minimum cell size for each species and year given the mode's uncertainty and the best one among the three cell sizes available:

```{r add_right_size}
mode_unc_df <- mode_unc_df %>%
  mutate(minimum_right_size = mode_uncertainty * 2) %>%
  rowwise() %>%
  mutate(minimum_grid_size = 
           sqrt(cell_sizes[which(cell_sizes > (minimum_right_size**2))[1]][[1]]))
mode_unc_df
```

We can now select the species-year combinations with sufficiently fine occurrence data to be fitted in the grid with the desired cell size of 1x1km:

```{r}
exact_data_df <- mode_unc_df %>%
  filter(minimum_grid_size == sqrt(cell_sizes[1][[1]]))
exact_data_df
```

We plot the occupancy for this subset:

We can now use the AOO at 1x1 km cell size of these species-year to evaluate other data at the same grain size:

```{r plot_for_subset_exact}
subset_use_all_sizes <- aoo_compare_tidy %>%
         right_join((exact_data_df %>%
                      select(species, speciesKey, year)), 
                   by = c("species", "speciesKey", "year")) %>%
         mutate(species_year = paste(species, year))
ggplot(subset_use_all_sizes,
         aes(x = log(cell_area), 
             y = log(occupancy), 
             color = species_year)) +
    geom_point() +
  geom_line() +
  labs(x = "log(area)", y = "log(occupancy)")
```

We can see that no signs of saturation (horizonta line) or endemism (completely straight line) (see Azaele et al., 2012 and  `vignette("Upgraining", package = "downscale")`) occurs at the cell sizes under consideration.

Although each species/year has a different occupancy, we can still see that the difference between (the logarithm of) occupancy at 10x10km cell size and 1x1km for this subset is quite similar:

```{r ovreview_diff_10_minus_1}
diff_10_1_df <- subset_use_all_sizes %>% 
  filter(grid_size %in% c("grid_1x1km", "grid_10x10km")) %>%
  select(-c(cell_area, aoo)) %>%
  spread(key = grid_size, value = occupancy) %>%
  group_by(species, speciesKey, species_year) %>%
  mutate(log_diff_10_1 = log(grid_10x10km) - log(grid_1x1km))

summary(diff_10_1_df$log_diff_10_1)
```

Or by species:

```{r plot_diffs}
map(unique(diff_10_1_df$species), function(x) {
  diff_10_1_df %>%
    filter(species == x) %>%
    pull(log_diff_10_1) %>%
    summary()
})
```

## 
