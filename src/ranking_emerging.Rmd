---
title: 'Ranking species by emerging status'
author:
- Damiano Oldoni
- Toon Van Daele
- Tim Adriaens
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
---

This document follows the modelling pipeline to produce a list of introduced species ranked by emerging status.

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries:

```{r load_libraries, message = FALSE}
library(tidyverse)      # To do data science
library(tidylog)        # To provide feedback on dplyr functions
library(here)           # To find files
```

# Get data

## GAM outputs

We read the emerging status based on GAM, saved as one of the outputs of [modelling pipeline](https://trias-project.github.io/indicators/):

```{r read_em_summary, message=FALSE}
method_gam <- "correct_baseline"
em_gam_occs_be <- read_tsv(
  here::here("data",
             "output",
             "GAM_outputs",
       paste0("summary_GAM_occurrences_belgium_",
              method_gam,
              ".tsv"))) %>%
  mutate(indicator = "occurrences_BE")

em_gam_occs_pa <- read_tsv(
  here::here("data",
             "output", 
             "GAM_outputs",
       paste0("summary_GAM_occurrences_pa_",
              method_gam,
              ".tsv")))  %>%
  mutate(indicator = "occurrences_pa")

em_gam_occupancy_be <- read_tsv(
  here::here("data",
             "output",
             "GAM_outputs",
       paste0("summary_GAM_occupancy_belgium_",
              method_gam,
              ".tsv"))) %>%
  mutate(indicator = "occupancy_BE")

em_gam_occupancy_pa <- read_tsv(
  here::here("data",
             "output", 
             "GAM_outputs",
             paste0("summary_GAM_occupancy_pa_",
                    method_gam,
                    ".tsv"))) %>%
  mutate(indicator = "occupancy_pa")

em_gam_list <- list(
  gam_occurrences_be = em_gam_occs_be,
  gam_occurrences_pa = em_gam_occs_pa,
  gam_occupancy_be = em_gam_occupancy_be,
  gam_occupancy_pa = em_gam_occupancy_pa) %>%
  map( ~ mutate(.data = .,
              model = "GAM"))
```

Preview:

```{r preview_gam}
map(em_gam_list, ~ head(., n = 10))
```

The emerging status (column `em_status`) score is encoded as follows:

- 3: emerging
- 2: potentially emerging
- 1: unclear
- 0: not emerging

As you can see in preview above, GAM could not be applied to all taxa (`em_status` = `NA`). Number of taxon/year combinations without emerging status:

```{r get_number_nas, message=FALSE}
sum(map_int(em_gam_list, 
            function(df) {
              df %>% filter(is.na(em_status)) %>% nrow
              }
            )
)
```

In these cases we will use the emerging status as assessed by applying decision rules.

## Decision rules outputs

We read the emerging status based on decision rules, saved as one of the outputs of [modelling pipeline](https://trias-project.github.io/indicators/):

```{r read_dr_results, message=FALSE}
em_decision_rules_occs_BE <- read_tsv(
  here::here("data", 
             "output",
             "decision_rules_outputs", 
             "output_decision_rules_occs_belgium.tsv"),
  na = "") %>%
  mutate(indicator = "occurrences_BE")

em_decision_rules_occs_pa <- read_tsv(
  here::here("data", 
             "output",
             "decision_rules_outputs", 
             "output_decision_rules_occs_pa.tsv"),
  na = "") %>%
  mutate(indicator = "occurrences_pa")

em_decision_rules_occupancy_BE <- read_tsv(
  here::here("data", 
             "output",
             "decision_rules_outputs", 
             "output_decision_rules_occupancy_belgium.tsv"),
  na = "") %>%
  mutate(indicator = "occupancy_BE")

em_decision_rules_occupancy_pa <- read_tsv(
  here::here("data", 
             "output",
             "decision_rules_outputs", 
             "output_decision_rules_occupancy_pa.tsv"),
  na = "") %>%
  mutate(indicator = "occupancy_pa")

em_decision_rules_list <- list(
  decision_rules_occurrences_be = em_decision_rules_occs_BE,
  decision_rules_occurrences_pa = em_decision_rules_occs_pa,
  decision_rules_occupancy_be = em_decision_rules_occupancy_BE,
  decision_rules_occupancy_pa = em_decision_rules_occupancy_pa) %>%
  map( ~ mutate(.data = .,
              model = "decision_rules"))
```

Preview:

```{r preview_dr_list}
map(em_decision_rules_list, ~ head(., n = 10))
```

## Scientific names

Read list of scientific names:

```{r read_taxa_names}
taxa_names <- read_tsv(
  here::here("data",
       "interim",
       "timeseries_taxonomic_info.tsv"),
  na = "")
```

These names will be added to ranking for better readibility.

# Preprocessing

Merge results from GAM and decision rules:

```{r concatenate_gam_decision_rules}
em_list <- append(em_gam_list, em_decision_rules_list)
```

Spread columns for ranking:

```{r spread_em_dfs}
# make a data.frame binding all dfs by row
em_df <- 
  bind_rows(em_list) %>%
  select(-c(starts_with("growth"),starts_with("dr"), method))

# spread by model
em_df <-
  em_df %>%
  pivot_wider(names_from = model,
              id_cols = c(taxonKey, year, indicator),
              values_from = em_status)

# assign unique emerging score (if GAM is NA, choose decision rules)
em_df <-
  em_df %>%
  mutate(em = ifelse(is.na(GAM), decision_rules, GAM))

# spread by years
em_df <- 
  em_df %>%
  pivot_wider(data = ., 
              names_from = year,
              values_from = em, 
              id_cols = c(taxonKey, indicator), 
              names_prefix = paste0("year_"))

# spread by indicator
em_df <- 
  em_df %>%
  pivot_wider(names_from = indicator,
              id_cols = taxonKey,
              values_from = starts_with("year"),
              names_prefix = "em_status_")
```

We also add scientific names:

```{r add_sc_names}
em_df <-
  em_df %>%
  left_join(taxa_names, by = "taxonKey")
```

# Ranking by emerging status

In this section we create the ranking of introduced species based on the emerging status. 

Ranking taxa based on emerging status. The ranking is based on the highest emerging status in:

1. most recent year
2. protected areas
3. occupancy

```{r rank_basic}
ranking_df <- 
  em_df %>%
  arrange(desc(year_2018_em_status_occupancy_pa),
          desc(year_2018_em_status_occurrences_pa),
          desc(year_2018_em_status_occupancy_BE),
          desc(year_2018_em_status_occurrences_BE),
          desc(year_2017_em_status_occupancy_pa),
          desc(year_2017_em_status_occurrences_pa),
          desc(year_2017_em_status_occupancy_BE),
          desc(year_2017_em_status_occurrences_BE),
          desc(year_2016_em_status_occupancy_pa),
          desc(year_2016_em_status_occurrences_pa),
          desc(year_2016_em_status_occupancy_BE),
          desc(year_2016_em_status_occurrences_BE)) %>%
  select(taxonKey, canonicalName, kingdom, class,
         year_2018_em_status_occupancy_pa,
         year_2018_em_status_occurrences_pa,
         year_2018_em_status_occupancy_BE,
         year_2018_em_status_occurrences_BE,
         year_2017_em_status_occupancy_pa,
         year_2017_em_status_occurrences_pa,
         year_2017_em_status_occupancy_BE,
         year_2017_em_status_occurrences_BE,
         year_2016_em_status_occupancy_pa,
         year_2016_em_status_occurrences_pa,
         year_2016_em_status_occupancy_BE,
         year_2016_em_status_occurrences_BE,
         everything())
ranking_df
```

## Point strategy

We can also rank using a point strategy:

```{r rank_by_em_pts}
ranking_pts <- 
  em_df %>%
  mutate(em_pts = year_2018_em_status_occupancy_pa * 3 +
           year_2018_em_status_occurrences_pa * 2.5 +
           year_2018_em_status_occupancy_BE * 2.5 +
           year_2018_em_status_occurrences_BE * 2 +
           year_2017_em_status_occupancy_pa * 2.5 +
           year_2017_em_status_occurrences_pa * 2 +
           year_2017_em_status_occupancy_BE * 2 +
           year_2017_em_status_occurrences_BE * 1.5 +
           year_2016_em_status_occupancy_pa * 2 +
           year_2016_em_status_occurrences_pa * 1.5 +
           year_2016_em_status_occupancy_BE * 1.5 +
           year_2016_em_status_occurrences_BE) %>%
  arrange(desc(em_pts)) %>%
  select(taxonKey, canonicalName, kingdom, class,
         em_pts, everything())
ranking_pts
```

